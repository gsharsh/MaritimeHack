---
phase: 05-pareto-frontier
plan: 01
type: execute
---

<objective>
Implement epsilon-constraint Pareto frontier: sweep CO2eq cap from fleet-max to fleet-min in 15 steps, solve MILP at each point, compute shadow carbon prices.

Purpose: Quantify the cost-emissions tradeoff curve — how much extra cost each tonne of CO2eq reduction requires.
Output: run_pareto_sweep() function returning Pareto points with cost, emissions, fleet, and shadow carbon prices.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-milp-optimizer/02-01-SUMMARY.md
@.planning/phases/04-safety-threshold-sweep/04-01-SUMMARY.md
@src/optimization.py
@src/sensitivity.py
@src/constants.py

**Tech stack available:** pulp, pandas, matplotlib (planned)
**Established patterns:** binary-milp-fleet-selection, linearized-avg-constraint, sweep-loop-over-milp-thresholds, infeasible-detection
**Constraining decisions:**
- Phase 02: Linearized safety constraint: sum(safety_i - threshold) >= 0
- Phase 02: Return empty list on infeasible (not raise)
- Phase 04: Infeasible thresholds shown as INFEASIBLE in table (not omitted)
- Phase 04: Sweep pattern: loop thresholds, call MILP, collect metrics dict per threshold
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add optional CO2eq cap to select_fleet_milp()</name>
  <files>src/optimization.py</files>
  <action>Add an optional parameter `co2_cap: float | None = None` to select_fleet_milp(). When co2_cap is not None, add an additional MILP constraint: `lpSum([co2eq_i * x[i] for i in indices]) <= co2_cap`. Read CO2eq values from df["CO2eq"] column (same column name used by total_cost_and_metrics). Do NOT change any existing behavior when co2_cap is None — all existing tests must still pass unchanged. Do NOT change the function signature's other defaults.</action>
  <verify>Run `python -m pytest tests/ -v` — all existing tests pass. Manually verify the new parameter exists: `python -c "from src.optimization import select_fleet_milp; import inspect; print('co2_cap' in inspect.signature(select_fleet_milp).parameters)"`</verify>
  <done>select_fleet_milp() accepts optional co2_cap parameter. co2_cap=None preserves existing behavior (all tests pass). co2_cap=float adds CO2eq upper bound constraint to MILP.</done>
</task>

<task type="auto">
  <name>Task 2: Implement run_pareto_sweep() with shadow carbon prices</name>
  <files>src/sensitivity.py</files>
  <action>Add run_pareto_sweep() to sensitivity.py. Algorithm:
1. Run base MILP (no CO2 cap) to get max emissions point (cost_min, co2_max)
2. Find fleet-min CO2eq: run MILP with objective = minimize CO2eq instead of cost. To do this, create a secondary MILP where objective is lpSum(co2eq_i * x_i) with same constraints (DWT, safety, fuel diversity). Extract min achievable CO2eq as co2_min. Use select_fleet_milp for the cost-minimizing base, but for the emissions-minimizing bound, build a quick local MILP or call select_fleet_milp with a very tight co2_cap and binary search. Simpler approach: iterate from total fleet CO2eq down to 0 to find the tightest feasible cap — BUT this is expensive. Best approach: build a one-off MILP in run_pareto_sweep that minimizes CO2eq subject to same feasibility constraints (DWT, safety, fuel diversity) to find co2_min directly.
3. Create 15 evenly-spaced epsilon values from co2_max down to co2_min (inclusive both endpoints).
4. For each epsilon, call select_fleet_milp(df, co2_cap=epsilon). Collect: epsilon, feasible, fleet_size, total_cost_usd, total_co2e_tonnes, avg_safety_score, total_dwt, selected_ids.
5. Compute shadow carbon price between consecutive feasible points: shadow_price = (cost_i - cost_{i-1}) / (co2eq_{i-1} - co2eq_i) — i.e., marginal USD per tonne CO2eq reduced. First point has no shadow price (None).
6. Return list of dicts with keys: epsilon, feasible, fleet_size, total_cost_usd, total_co2e_tonnes, avg_safety_score, total_dwt, selected_ids, shadow_carbon_price.

Also add format_pareto_table(results) that returns a pandas DataFrame with columns: CO2eq Cap, Feasible, Fleet Size, Total Cost ($), Actual CO2eq (t), Shadow Price ($/tCO2eq), Avg Safety. Format numbers with commas, 2 decimal places. Infeasible rows show "INFEASIBLE" like the sweep table pattern.

Import what you need from pulp (LpMinimize, LpProblem, LpVariable, LpBinary, PULP_CBC_CMD, lpSum) for the min-emissions MILP. Import MONTHLY_DEMAND and SAFETY_THRESHOLD from constants.</action>
  <verify>Run `python -m pytest tests/ -v` — all existing tests still pass (no regressions). Test manually: `python -c "from src.sensitivity import run_pareto_sweep; print('OK')"` confirms import works.</verify>
  <done>run_pareto_sweep() and format_pareto_table() exist in sensitivity.py. Function computes 15-point Pareto frontier with shadow carbon prices. Returns list of dicts with all required fields.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -m pytest tests/ -v` passes all existing tests
- [ ] `python -c "from src.optimization import select_fleet_milp; from src.sensitivity import run_pareto_sweep, format_pareto_table; print('imports OK')"` succeeds
- [ ] select_fleet_milp() has co2_cap parameter
- [ ] run_pareto_sweep() returns list of dicts with shadow_carbon_price field
</verification>

<success_criteria>

- All existing tests pass (no regressions)
- select_fleet_milp() accepts co2_cap parameter
- run_pareto_sweep() computes 15-point Pareto frontier
- Shadow carbon prices computed between consecutive feasible points
- format_pareto_table() produces readable output
</success_criteria>

<output>
After completion, create `.planning/phases/05-pareto-frontier/05-01-SUMMARY.md`
</output>
