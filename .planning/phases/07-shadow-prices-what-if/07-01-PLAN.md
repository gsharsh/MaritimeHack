---
phase: 07-shadow-prices-what-if
type: execute
---

<objective>
Extract shadow prices via constraint perturbation (DWT demand and safety threshold), run drop-diversity what-if analysis, and compute cost-per-DWT efficiency metrics.

Purpose: Quantify the marginal cost of tightening key constraints — essential for the "beyond the brief" stretch analysis in the case paper and presentation.
Output: New sensitivity functions in src/sensitivity.py, wired into run.py with --shadow-prices flag, console output showing shadow prices table, what-if comparison, and efficiency metrics.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-safety-threshold-sweep/04-01-SUMMARY.md
@.planning/phases/05-pareto-frontier/05-02-SUMMARY.md
@.planning/phases/06-submission-charts/06-02-SUMMARY.md

@src/optimization.py
@src/sensitivity.py
@src/constants.py
@run.py

**Tech stack available:** PuLP, pandas, numpy, matplotlib (Agg backend)
**Established patterns:** sweep-loop-over-milp-thresholds, carbon-price-adjustment-sweep, cli-flag-pattern
**Constraining decisions:**
- Phase 4: Sweep pattern = loop values, call MILP, collect metrics dict
- Phase 5: Shadow carbon price = marginal cost per tonne CO2eq between consecutive Pareto points
- Phase 6: --all flag enables all analysis modes; charts use Agg backend + 150 DPI
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement shadow price extraction via constraint perturbation</name>
  <files>src/sensitivity.py</files>
  <action>
Add two functions to src/sensitivity.py:

1. `compute_shadow_prices(df, cargo_demand, safety_threshold)` — returns a dict with:
   - `dwt_shadow_price`: Perturb DWT demand by +1% (cargo_demand * 1.01), re-solve MILP, compute (new_cost - base_cost) / (demand_delta). This gives $/tonne-DWT of additional capacity.
   - `safety_shadow_price`: Perturb safety threshold by +0.1 (e.g., 3.0 -> 3.1), re-solve MILP, compute (new_cost - base_cost) / 0.1. This gives $/unit increase in avg safety requirement.
   - Include base_cost, perturbed_cost_dwt, perturbed_cost_safety, base_fleet_size, perturbed_fleet_size_dwt, perturbed_fleet_size_safety.
   - If perturbed problem is infeasible, set shadow price to None and note "infeasible at perturbation".

2. `format_shadow_prices(shadow_results)` — returns a formatted string table (not DataFrame — simple print-friendly text) showing:
   - Constraint | Base Value | Perturbed Value | Base Cost | New Cost | Shadow Price | Interpretation
   - Two rows: DWT demand and Safety threshold

Follow the established sweep pattern: call select_fleet_milp() with modified parameters, collect metrics via total_cost_and_metrics().
  </action>
  <verify>
Run `python -c "from src.sensitivity import compute_shadow_prices, format_shadow_prices; print('imports ok')"` — no import errors.
  </verify>
  <done>
compute_shadow_prices() returns dict with dwt_shadow_price and safety_shadow_price floats (or None if infeasible). format_shadow_prices() returns readable string table.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement drop-diversity what-if and cost-per-DWT efficiency</name>
  <files>src/sensitivity.py</files>
  <action>
Add two more functions to src/sensitivity.py:

1. `run_diversity_whatif(df, cargo_demand, safety_threshold)` — returns a dict comparing:
   - `with_diversity`: Run MILP with require_all_fuel_types=True, collect metrics + selected_ids + fuel_type_counts.
   - `without_diversity`: Run MILP with require_all_fuel_types=False, collect same.
   - `cost_savings`: without_diversity cost - with_diversity cost (negative means cheaper without constraint).
   - `fleet_size_diff`: difference in fleet sizes.
   - `fuel_types_lost`: set of fuel types present with diversity but missing without.
   - This answers "what is the cost of the fuel diversity constraint?"

2. `compute_fleet_efficiency(df, selected_ids)` — returns a dict with:
   - `cost_per_dwt`: total_cost / total_dwt ($/tonne capacity)
   - `cost_per_vessel`: total_cost / fleet_size
   - `dwt_per_vessel`: total_dwt / fleet_size (average vessel size)
   - `co2_per_dwt`: total_co2e / total_dwt (emissions intensity)
   - `utilization`: total_dwt / cargo_demand (capacity utilization ratio)
   Uses total_cost_and_metrics() to get base numbers. Takes cargo_demand as optional param for utilization calc.

Both follow existing patterns — call select_fleet_milp(), collect via total_cost_and_metrics().
  </action>
  <verify>
Run `python -c "from src.sensitivity import run_diversity_whatif, compute_fleet_efficiency; print('imports ok')"` — no import errors.
  </verify>
  <done>
run_diversity_whatif() returns comparison dict with cost_savings and fuel_types_lost. compute_fleet_efficiency() returns efficiency ratios.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire shadow prices, what-if, and efficiency into run.py CLI</name>
  <files>run.py</files>
  <action>
Add to run.py:

1. New `--shadow-prices` CLI flag (action="store_true", default=False). Add it to the --all convenience group.

2. New section in main() (after carbon sweep, before end) that runs when --shadow-prices is True:
   a. Print "Shadow Prices (Constraint Perturbation)" header.
   b. Call compute_shadow_prices(df, args.cargo_demand, args.safety_threshold).
   c. Print formatted shadow prices via format_shadow_prices().
   d. Print "Fuel Diversity What-If Analysis" header.
   e. Call run_diversity_whatif(df, args.cargo_demand, args.safety_threshold).
   f. Print comparison: with vs without diversity constraint (cost, fleet size, fuel types).
   g. Print "Fleet Efficiency Metrics" header.
   h. Call compute_fleet_efficiency(df, selected_ids, cargo_demand=args.cargo_demand) for the base case fleet.
   i. Print efficiency metrics: cost/DWT, cost/vessel, DWT/vessel, CO2/DWT, utilization.

3. Add imports for the new functions from src.sensitivity.

Follow existing console output style: header bars with "=" * 60, indented key-value pairs.
  </action>
  <verify>
Run `python run.py --shadow-prices --cargo-demand 800000` with test fixtures — should print shadow prices, diversity what-if, and efficiency metrics without errors.
  </verify>
  <done>
--shadow-prices flag works standalone and as part of --all. Shadow prices, diversity what-if, and efficiency metrics print correctly to console. No errors with test fixtures.
  </done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `python run.py --shadow-prices --cargo-demand 800000` runs without errors
- [ ] `python run.py --all --cargo-demand 800000` includes shadow prices output
- [ ] Shadow prices show sensible values (positive cost increase for tighter constraints)
- [ ] Diversity what-if shows cost difference with/without fuel diversity
- [ ] Efficiency metrics show cost/DWT, CO2/DWT, utilization ratios
- [ ] No import errors or warnings
</verification>

<success_criteria>

- All 3 tasks completed
- All verification checks pass
- No errors or warnings introduced
- Shadow prices quantify marginal cost of DWT and safety constraints
- Diversity what-if quantifies cost of fuel diversity requirement
- Efficiency metrics provide cost/DWT and emissions intensity ratios
- --shadow-prices flag integrated into --all convenience flag
</success_criteria>

<output>
After completion, create `.planning/phases/07-shadow-prices-what-if/07-01-SUMMARY.md`
</output>
