---
phase: 02-milp-optimizer
plan: 01
type: tdd
---

<objective>
Build `select_fleet_milp()` function using PuLP binary MILP with test-driven development.

Purpose: The MILP solver is the core deliverable — it must correctly minimize total fleet cost subject to DWT demand, average safety, and fuel diversity constraints. TDD ensures correctness against known SOP checkpoint values before wiring into the pipeline.
Output: Tested `select_fleet_milp()` in `src/optimization.py` with passing tests.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-clean-slate-data-foundation/01-01-SUMMARY.md
@.planning/phases/01-clean-slate-data-foundation/01-02-SUMMARY.md
@.planning/phases/01-clean-slate-data-foundation/01-03-SUMMARY.md

@src/optimization.py
@src/constants.py
@src/data_adapter.py
@tests/fixtures/checkpoint_vessels.csv

**Tech stack available:** pandas, PuLP>=2.7.0 (CBC solver), pytest
**Established patterns:** functional/procedural style, no classes, constants from src/constants.py, data via load_per_vessel()

**Constraining decisions:**
- Phase 1: PuLP enabled in requirements.txt, OR-Tools removed
- Phase 1: All constants in src/constants.py as single source of truth
- Phase 1: load_per_vessel() auto-falls back to test fixtures when per_vessel.csv absent
- Phase 1: Kept validate_fleet, total_cost_and_metrics, format_outputs, submission_outputs for reuse

**PuLP API patterns (from Context7 docs):**
```python
from pulp import LpProblem, LpMinimize, LpVariable, LpBinary, lpSum, PULP_CBC_CMD

prob = LpProblem("name", LpMinimize)
x = LpVariable.dicts("x", indices, 0, 1, LpBinary)
prob += lpSum([cost[i] * x[i] for i in indices])  # objective
prob += lpSum([dwt[i] * x[i] for i in indices]) >= demand  # constraint
prob.solve(PULP_CBC_CMD(msg=0))
selected = [i for i in indices if x[i].varValue > 0.5]
```
</context>

<feature>
  <name>select_fleet_milp — Binary MILP fleet selector</name>
  <files>src/optimization.py, tests/test_milp.py</files>
  <behavior>
    Function signature:
    ```python
    def select_fleet_milp(
        df: pd.DataFrame,
        cargo_demand: float = MONTHLY_DEMAND,
        min_avg_safety: float = SAFETY_THRESHOLD,
        require_all_fuel_types: bool = True,
    ) -> list[int]:
    ```

    Returns list of selected vessel_id values (integers).

    **MILP formulation:**
    - Decision variables: x_i ∈ {0,1} for each vessel i
    - Objective: minimize Σ x_i × final_cost_i
    - Constraint 1 (DWT): Σ x_i × dwt_i >= cargo_demand
    - Constraint 2 (Safety): Σ x_i × (safety_score_i - min_avg_safety) >= 0
      (This linearizes the average: avg(safety) >= threshold ⟺ Σ(safety - threshold) >= 0)
    - Constraint 3 (Fuel diversity): For each fuel_type f in dataset:
      Σ x_i (where vessel i has fuel_type f) >= 1

    **Test cases with 5 checkpoint vessels:**
    Fixtures: vessel 10102950 (175108 DWT, safety=1, Distillate, $880,688),
              10657280 (206331 DWT, safety=3, Ammonia, $1,260,216),
              10791900 (179700 DWT, safety=5, LNG, $1,043,965),
              10522650 (115444 DWT, safety=3, Methanol, $1,156,134),
              10673120 (178838 DWT, safety=3, Hydrogen, $1,185,540)

    Total DWT of all 5: 855,421. Total demand: 4,576,667.
    With only 5 vessels, DWT constraint requires ALL 5 to be selected (855,421 < 4,576,667).
    So with default cargo_demand, solver MUST select all 5 — but that may be infeasible
    since avg safety = (1+3+5+3+3)/5 = 3.0 which exactly meets threshold.

    Test cases:
    1. **All vessels selected when demand requires it** — set cargo_demand=855_421 (sum of all 5 DWT), require_all_fuel_types=False, min_avg_safety=1.0 → solver selects cheapest subset meeting DWT. With demand=855421 all 5 needed (since removing any one drops below).
       Actually: 855421 - 115444(Methanol) = 739977 < 855421. All 5 required.
       Expected: all 5 selected, total cost = sum of all 5 final_costs.

    2. **Respects DWT constraint** — set cargo_demand=700_000, require_all_fuel_types=False, min_avg_safety=1.0 → solver can drop at least one vessel. Should drop the most expensive one(s) while meeting DWT. Most expensive is Ammonia ($1,260,216, 206331 DWT). Without Ammonia: 649090 DWT < 700000. So need to keep Ammonia OR find another combo. Let's check combos meeting >= 700000:
       - All 5: 855421 ✓
       - Drop cheapest (Distillate $880688, 175108 DWT): 680313 < 700000 ✗
       - Drop Methanol ($1,156,134, 115444 DWT): 739977 ✓ cost=$4,370,409
       - Drop Hydrogen ($1,185,540, 178838 DWT): 676583 < 700000 ✗
       - Drop LNG ($1,043,965, 179700 DWT): 675721 < 700000 ✗
       - Drop Ammonia ($1,260,216, 206331 DWT): 649090 < 700000 ✗
       Only valid 4-vessel subset: drop Methanol → cost $4,370,409
       All 5: cost $5,526,543
       Winner: drop Methanol → $4,370,409
       Expected: [10102950, 10657280, 10791900, 10673120], cost = $4,370,409

    3. **Safety constraint works** — set cargo_demand=500_000, require_all_fuel_types=False, min_avg_safety=3.0 → must pick vessels where Σ(safety_i - 3.0) >= 0. Vessel 10102950 has safety=1, contributing -2.0. Need enough safety-3+ vessels to offset.
       Check: can we exclude vessel 10102950 (safety=1, cheapest at $880,688)?
       Without 10102950: DWT=680313 >= 500000 ✓. Safety contributions: (3-3)+(5-3)+(3-3)+(3-3)=2.0 >= 0 ✓
       Cost without 10102950: $4,645,855
       With all 5: cost=$5,526,543, safety sum = (1-3)+(3-3)+(5-3)+(3-3)+(3-3) = -2+0+2+0+0 = 0 >= 0 ✓
       Can we find cheaper? 3-vessel combos meeting DWT>=500000 and safety>=0:
       - {Ammonia(206331), LNG(179700), Hydrogen(178838)}: DWT=564869 ✓, safety=(0+2+0)=2 ✓, cost=$3,489,721
       - {Ammonia(206331), LNG(179700), Methanol(115444)}: DWT=501475 ✓, safety=(0+2+0)=2 ✓, cost=$3,460,315
       - {Ammonia(206331), LNG(179700), Distillate(175108)}: DWT=561139 ✓, safety=(0+2-2)=0 ✓, cost=$3,184,869
       Winner: {Distillate, Ammonia, LNG} at $3,184,869
       Expected: [10102950, 10657280, 10791900], total cost = $3,184,869

    4. **Fuel diversity constraint works** — set cargo_demand=500_000, min_avg_safety=1.0, require_all_fuel_types=True → must have at least one of each fuel type in dataset (5 types in fixtures). All 5 must be selected.
       Expected: all 5 selected.

    5. **Returns empty list on infeasible** — set cargo_demand=999_999_999 → impossible.
       Expected: empty list (or raises, but empty list is cleaner for downstream).

    6. **Solver returns sorted vessel IDs** — for deterministic output.
  </behavior>
  <implementation>
    In src/optimization.py, replace `select_fleet_greedy()` with `select_fleet_milp()`.

    Implementation approach:
    1. Import pulp (LpProblem, LpMinimize, LpVariable, LpBinary, lpSum, PULP_CBC_CMD)
    2. Build index from df.index (row positions) mapped to vessel_id
    3. Create binary variables: x[i] for each row index i
    4. Objective: minimize Σ x[i] * df.iloc[i]["final_cost"]
    5. Constraint DWT: Σ x[i] * df.iloc[i]["dwt"] >= cargo_demand
    6. Constraint Safety (linearized): Σ x[i] * (df.iloc[i]["safety_score"] - min_avg_safety) >= 0
    7. Constraint Fuel diversity (if require_all_fuel_types): for each unique fuel_type f, Σ x[i] for i where fuel_type==f >= 1
    8. Solve with PULP_CBC_CMD(msg=0)
    9. Check status == 1 (Optimal). If not, return empty list.
    10. Extract selected: sorted([vessel_id[i] for i in indices if x[i].varValue > 0.5])
    11. Return sorted list of vessel_id integers

    Keep it simple — no classes, no over-engineering. Just a function.
    Do NOT use df.iterrows() for building constraints (slow). Use vectorized index mapping.
    Do NOT silence solver errors — if PuLP not installed, let ImportError propagate.
  </implementation>
</feature>

<verification>
```bash
python -m pytest tests/test_milp.py -v
```
All 5-6 test cases pass.
</verification>

<success_criteria>
- Failing tests written and committed (RED)
- select_fleet_milp() implemented and all tests pass (GREEN)
- Refactor if needed (REFACTOR)
- All 2-3 commits present
- select_fleet_greedy() removed or kept as alias raising NotImplementedError
- Function handles infeasible problems gracefully (empty list)
</success_criteria>

<output>
After completion, create `.planning/phases/02-milp-optimizer/02-01-SUMMARY.md`:

# Phase 2 Plan 01: MILP Solver (TDD) Summary

**[one-liner]**

## RED
- What test was written, why it failed

## GREEN
- What implementation made it pass

## REFACTOR
- What cleanup was done (if any)

## Commits
- List of commits produced
</output>
